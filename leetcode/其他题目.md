# 其他题目集锦

## 位操作相关
#### LC338.比特位计数
比较直接的方法，每个数都转化为二进制，然后用count查询1的个数。  
O(nk)/O(n)
```python
class Solution:
    def countBits(self, num: int) -> List[int]:
        res = []
        for i in range(num + 1):
            res.append(bin(i).count('1', 2))
        return res
```

dp方法1：
- 某个偶数肯定能由前面的某个数左移一位得到，如十进制6对应的二进制为110，由十进制3对应二进制11左移一位得到。
- 某个奇数肯定能由前面的某个数左移一位并加上1得到，如十进制7对应的二进制为111，是由十进制3对应二进制11左移一位为110并加一得到。  

O(n)/O(n)
```python
class Solution:
    def countBits(self, num: int) -> List[int]:
        dp=[0]*(num+1)
        for i in range(num//2+1):
            dp[i*2]=dp[i] # 偶数位1
            if i*2+1<=num:
                dp[i*2+1]=dp[i]+1 # 奇数位1
        return dp
```
dp方法2：
- 通过i&(i-1)消除最低位，剩余的数同样小于当前的i且已被计算过。
- 状态转移方程：dp[i]=dp[i&(i-1)]+1。  

O(n)/O(n)
```python
class Solution:
    def countBits(self, num: int) -> List[int]:
        dp=[0]*(num+1)
        for i in range(1,num+1):
            dp[i]=dp[i&(i-1)]+1
        return dp
```

## 类设计问题

#### 剑指offer 09.用两个堆栈实现队列
总体上就是一个堆栈用来当队列，一个用以辅助。
```python
class CQueue:

    def __init__(self):
        self.stack1 = []
        self.stack2 = []

    def appendTail(self, value: int) -> None:
        while self.stack1:
            self.stack2.append(self.stack1.pop())
        self.stack1.append(value)

        while self.stack2:
            self.stack1.append(self.stack2.pop())
        return self.stack1

    def deleteHead(self) -> int:
        if not self.stack1: return -1
        return self.stack1.pop()
```
