# 动态规划总结
lc中比较大规模的在面试中经常出现的一类题就是动态规划，这个类型的题目也算是LC中普遍比较难的题目。难在一如何写出状态定义，二状态转移方程是否合理。  

**关键词：计数，求最大值，最小值，求存在性。** 

DP问题包含重叠子问题和最优子结构，重叠子问题是子问题会多次出现，因此需要DP表把之前的结果记录下来；最优子结构就算现在和之前状态存在递推关系，就是dp[i]=dp[i-1]+1这样的转移方程。

步骤：
1. 确定状态：1）研究最优策略的最后一步，2）化为子问题。
2. 状态转移方程：根据子问题定义直接得到。
3. 初始条件和边界条件界定。
4. 计算顺序。

#### LC70.爬楼梯
入门DP的题目，爬楼梯的最后一步是，在登上最后一级台阶时，可以从n-1或者n-2级上来，同样在n-1级上也对应可以从n-2和n-3级上来。所以我们的状态定义是共有多少种方法登上第i层。
而其对应的状态转移方程也就是第i层的方法等于第i-1和第i-2的方法的和。
```python
dp[i] = dp[i-1] + dp[i-2]
```
所以我们首先可用的通用方法为：
```python
class Solution:
    def climbStairs(self, n: int) -> int:
        if n <= 2: return n
        dp = [0]*n
        dp[0] = 1
        dp[1] = 2
        for i in range(2, n):
            dp[i] = dp[i-1] + dp[i-2]
        return dp[n-1]
```
上述方法时间复杂度和空间复杂度分别为O(n)和O(n)，并发现其实每次计算也只用到了两个变量，所以可以用滚动数组的方法，将空间复杂度进一步降低到O(1)。
```python
class Solution:
    def climbStairs(self, n: int) -> int:
        if n==1 or n==2: return n
        a, b, temp = 1, 2, 0
        for i in range(3,n+1):
            temp = a + b
            a = b
            b = temp
        return temp
```
