# 动态规划总结
lc中比较大规模的在面试中经常出现的一类题就是动态规划，这个类型的题目也算是LC中普遍比较难的题目。难在一如何写出状态定义，二状态转移方程是否合理。  

**关键词：计数，求最大值，最小值，求存在性。** 

DP问题包含重叠子问题和最优子结构，重叠子问题是子问题会多次出现，因此需要DP表把之前的结果记录下来；最优子结构就算现在和之前状态存在递推关系，就是dp[i]=dp[i-1]+1这样的转移方程。

步骤：
1. 确定状态：1）研究最优策略的最后一步，2）化为子问题。
2. 状态转移方程：根据子问题定义直接得到。
3. 初始条件和边界条件界定。
4. 计算顺序。

#### LC70.爬楼梯
入门DP的题目，归属于计数问题。爬楼梯的最后一步是，在登上最后一级台阶时，可以从n-1或者n-2级上来，同样在n-1级上也对应可以从n-2和n-3级上来，则由此发现可以用递归来更新状态转移方程。所以我们的状态定义是共有多少种方法登上第i层。
而其对应的状态转移方程也就是第i层的方法等于第i-1和第i-2的方法的和。
```python
dp[i] = dp[i-1] + dp[i-2]
```
所以我们首先可用的通用方法为：
```python
class Solution:
    def climbStairs(self, n: int) -> int:
        if n <= 2: return n
        dp = [0]*n
        dp[0] = 1
        dp[1] = 2
        for i in range(2, n):
            dp[i] = dp[i-1] + dp[i-2]
        return dp[n-1]
```
上述方法时间复杂度和空间复杂度分别为O(n)和O(n)，并发现其实每次计算也只用到了两个变量，所以可以用滚动数组的方法，将空间复杂度进一步降低到O(1)。
```python
class Solution:
    def climbStairs(self, n: int) -> int:
        if n==1 or n==2: return n
        a, b, temp = 1, 2, 0
        for i in range(3,n+1):
            temp = a + b
            a = b
            b = temp
        return temp
```

#### LC509.斐波那契数列
这道题跟上面的70爬楼梯是一道题，题干已经直接把状态转移方程给出来了。所以这里用的方法是一样的。
```python
class Solution:
    def fib(self, n: int) -> int:
        if n == 0: return 0
        elif n == 1: return 1
        else:
            f0, f1  = 0, 1
            for i in range(2, n + 1):
                tmp = f1 + f0
                f0 = f1
                f1 = tmp
        return tmp
```

#### LC198.打家劫舍
这道题也是很经典的dp套路问题，题目属于**求最值**。
状态定义为：在偷到最后一家时的最大收益。  
状态转移方程：dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])，对此解释为当偷第i家时，只能偷i-2家，此时的收益与与偷i-1家的收益取最大值作为在偷到第i家的最大收益。
```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 0: return 0
        N = len(nums)
        dp = [0]*(N+1)
        dp[1] = nums[0]
        for i in range(2, N+1):
            dp[i] = max(dp[i - 1], nums[i - 1] + dp[i - 2])
        return dp[-1]
```
