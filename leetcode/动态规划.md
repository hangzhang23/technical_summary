# 动态规划总结
leetcode中比较大规模的在面试中经常出现的一类题就是动态规划，这个类型的题目也算是LC中普遍比较难的题目。难在一如何**写出状态定义**，二**状态转移方程**是否合理。  

**关键词：计数，求最大值，最小值，求存在性。** 

DP问题包含重叠子问题和**最优子结构**，重叠子问题是子问题会多次出现，因此需要DP表把之前的结果记录下来；最优子结构就算现在和之前状态存在递推关系，且子问题之间都是相互独立的，就是dp[i]=dp[i-1]+1这样的转移方程。

步骤：
1. 确定状态：1）研究最优策略的最后一步，2）化为子问题。
2. 状态转移方程：根据子问题定义直接得到。
3. 初始条件和边界条件界定。
4. 计算顺序。

时间复杂度：子问题总数$\times$解决每个子问题的时间

#### LC70.爬楼梯
入门DP的题目，归属于计数问题。爬楼梯的最后一步是，在登上最后一级台阶时，可以从n-1或者n-2级上来，同样在n-1级上也对应可以从n-2和n-3级上来，则由此发现可以用递归来更新状态转移方程。所以我们的状态定义是共有多少种方法登上第i层。
而其对应的状态转移方程也就是第i层的方法等于第i-1和第i-2的方法的和。
```python
dp[i] = dp[i-1] + dp[i-2]
```
所以我们首先可用的通用方法为：
```python
class Solution:
    def climbStairs(self, n: int) -> int:
        if n <= 2: return n
        dp = [0]*n
        dp[0] = 1
        dp[1] = 2
        for i in range(2, n):
            dp[i] = dp[i-1] + dp[i-2]
        return dp[n-1]
```
上述方法时间复杂度和空间复杂度分别为O(n)和O(n)，并发现其实每次计算也只用到了两个变量，所以可以用滚动数组的方法，将空间复杂度进一步降低到O(1)。
```python
class Solution:
    def climbStairs(self, n: int) -> int:
        if n==1 or n==2: return n
        a, b, temp = 1, 2, 0
        for i in range(3,n+1):
            temp = a + b
            a = b
            b = temp
        return temp
```

#### LC509.斐波那契数列
这道题跟上面的70爬楼梯是一道题，题干已经直接把状态转移方程给出来了。所以这里用的方法是一样的。
```python
class Solution:
    def fib(self, n: int) -> int:
        if n == 0: return 0
        elif n == 1: return 1
        else:
            f0, f1  = 0, 1
            for i in range(2, n + 1):
                tmp = f1 + f0
                f0 = f1
                f1 = tmp
        return tmp
```

#### LC198.打家劫舍
这道题也是很经典的dp套路问题，题目属于**求最值**。
状态定义为：在偷到最后一家时的最大收益。  
状态转移方程：dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])，对此解释为当偷第i家时，只能偷i-2家，此时的收益与与偷i-1家的收益取最大值作为在偷到第i家的最大收益。
```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 0: return 0
        N = len(nums)
        dp = [0]*(N+1)
        dp[1] = nums[0]
        for i in range(2, N+1):
            dp[i] = max(dp[i - 1], nums[i - 1] + dp[i - 2])
        return dp[-1]
```
用来降低空间复杂度的方法O(1):
```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        pre2 = 0
        pre1 = 0
        for i in range(0, len(nums)):
            cur = max(pre2 + nums[i], pre1)
            pre2 = pre1
            pre1 = cur

        return pre1
```

#### LC322.零钱兑换
零钱兑换是一个**求最值**的典型dp问题，他的子问题是：n-1个硬币的最少硬币数。假如有1，2，5三种硬币，目标金额是11，则拼出11元的最少硬币数的子问题就是分别拼出10，9，6元的最少硬币数再+1，很明显这三个字问题是相互独立的。  
状态定义：目标为target时的最少硬币数。  
状态转移方程：
$$
dp\left ( n \right )\left\{\begin{matrix}
0 &,n=0 \\ 
-1&,n<0 \\
min\left \{ dp(n-coin)+1, coin\in coins \right \}&,n>0
\end{matrix}\right.
$$
```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        def dp(n):
            if n == 0: return 0
            if n < 0: return -1
            res = float('inf')
            for coin in coins:
                if dp(n - coin) == -1: continue
                res = min(res, 1 + dp(n - coin))
            return res if res != float('inf') else -1
        return dp(amount)
```
