# 递归题目总结
递归解题的基本套路（四步曲）：  
1. 先定义一个函数，明确这个函数的功能，由于递归的特点是问题和子问题都会调用函数自身，所以这个函数的功能一旦确定了， 之后只要找寻问题与子问题的递归关系即可；  
2. 接下来寻找问题与子问题间的关系（即递推公式），这样由于问题与子问题具有相同解决思路，只要子问题调用步骤 1 定义好的函数，问题即可解决。所谓的关系最好能用一个公式表示出来，比如 f(n) = n * f(n-) 这样，如果暂时无法得出明确的公式，用伪代码表示也是可以的, 发现递推关系后，要寻找最终不可再分解的子问题的解，即（临界条件），确保子问题不会无限分解下去。由于第一步我们已经定义了这个函数的功能，所以当问题拆分成子问题时，子问题可以调用步骤 1 定义的函数，符合递归的条件（函数里调用自身）；  
3. 将第二步的递推公式用代码表示出来补充到步骤 1 定义的函数中；  
4. 最后也是很关键的一步，根据问题与子问题的关系，推导出时间复杂度,如果发现递归时间复杂度不可接受，则需转换思路对其进行改造，看下是否有更靠谱的解法。  

重点词：
- *多少可能性*，f(n)和f(n-1)...f(1)之间有联系
#### 1. 剑指offer 10-II 青蛙跳台阶
这是一道最有代表性的递归题目，青蛙在跳最后一步时只有两种情况：
- **当为1级台阶**： 剩n-1台阶，此情况共有f(n-1)种跳法；
- **当为2级台阶**： 剩n-2台阶，此情况共有f(n-2)种跳法。
f(n)为以上两种情况之和，f(n)=f(n-1)+f(n-2), 由此发现，可转化为**斐波那契数列第n项的值**，唯一不同在于起始数据不同。
1. 普通递归法（超时）：
- 终止条件f(0)=1， f(1)=1.
```python
class Solution:
    def numWays(self, n: int) -> int:
        if n == 0: return 1
        if n == 1: return 1
        return self.numWays(n-1) + self.numWays(n-2)
```
2. 备忘录递归：
- 终止条件f(0)=1， f(1)=1.
- 额外添加一个列表储存已经得到的数，这样在下次计算直接查表就可以，降低时间复杂度，但额外空间复杂度提升O(n).
```python
class SolutionHelper:
    def __init__(self):

        n = 101
        self.nums = nums = [0]*n
        nums[0] = 1
        nums[1] = 1
        nums[2] = 2

        def helper(k):
            if nums[k]:
                return nums[k]
            nums[k] = helper(k-1) + helper(k-2)
            return nums[k]

        helper(n-1)  

class Solution:
    sh = SolutionHelper()
    def numWays(self, n: int) -> int:
        return self.sh.nums[n] % 1000000007
```
3. 动态规划
状态转移方程也是上面描述的样子，所以也可以用dp来求。
```python
class Solution:
    def numWays(self, n: int) -> int:
        if n == 0 or n == 1: return 1
        n1, n2 = 1, 1
        for _ in range(2,n+1):
            n1,n2 = (n1+n2)%(1e9+7), n1
        return int(n1%(1e9+7))
```

#### 2. 剑指offer 10-I 斐波那契数列
跟青蛙跳台阶十分相似，只是边界条件转为了：
- 终止条件f(0)=0， f(1)=1
1. 标准递归（超时）
```python
class Solution:
    def fib(self, n: int) -> int:
        if n==0:return 0
        if n==1:return 1
        return (self.fib(n-1)+self.fib(n-2))%1000000007
```
2. 记忆性递归（超时）
```python
class Solution:
    def fib(self, n: int) -> int:
        records = [-1 for i in range(n+1)]
        if n==0:return 0
        if n==1:return 1
        if records[n] == -1:
            records[n] = self.fib(n-1) + self.fib(n-2)
        return records[n]
```
3. 循环迭代
```python
class Solution:
    def fib(self, n: int) -> int:
        if n <= 1: return n 
        a, b = 0, 1
        # 经过n次迭代，a就是f(n)结果值
        for _ in range(n):
            a, b = b, a + b 
        return a % 1000000007
```

#### LC394.字符串解码
这道题还有对应的[堆栈解法](https://github.com/hangzhang23/technical_summary/blob/master/leetcode/%E5%A0%86%E6%A0%88.md)，解题思想是差不多的。
```python
class Solution:
    def decodeString(self, s: str) -> str:
        def dfs(s, i):
            res, multi = "", 0
            while i < len(s):
                if '0' <= s[i] <= '9':
                    multi = multi * 10 + int(s[i])
                elif s[i] == '[':
                    i, tmp = dfs(s, i + 1)
                    res += multi * tmp
                    multi = 0
                elif s[i] == ']':
                    return i, res
                else:
                    res += s[i]
                i += 1
            return res
        return dfs(s,0)
```

#### 剑指0ffer 24.反转链表

```python
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        def recur(cur, pre):
            if not cur: return pre     # 终止条件
            res = recur(cur.next, cur) # 递归后继节点
            cur.next = pre             # 修改节点引用指向
            return res                 # 返回反转链表的头节点
        
        return recur(head, None) 
```
