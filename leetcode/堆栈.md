# 堆栈题目汇总

#### LC394.字符串解码
这道题看到括号就很容易联想到使用堆栈，这里堆栈负责装两个东西，一个表示当前括号对应的乘数，一个是括号内的字符。
```python
class Solution:
    def decodeString(self, s: str) -> str:
        if not s: return ''
        stack, multi, res = [], 0, ''
        for c in s:
            if '0'<= c <= '9':
                multi = multi*10 + int(c)
            elif c == '[':
                stack.append([multi, res])
                multi, res = 0, ''
            elif c == ']':
                [cur_multi, pre_res] = stack.pop()
                res = pre_res + res * cur_multi
            else:
                res += c
        return res
```

## 辅助栈

#### LC946.验证栈序列（剑指offer 41. 栈的压入弹出序列）
这道题用一个辅助栈来实现栈的压入和弹出操作：  
- 把pushed里的每个元素都压入stack里；
 - 在每次stack玩成push工作后，对stack判断，只要stack不为空，且stack的顶部元素和popped的顺序元素能对应，就一直弹出stack顶部，否则跳出循环，或者一旦弹空就添加下一个pushed的到stack
- 如果最终stack为空则两个序列对应。
```python
class Solution:
    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:
        if not pushed and not popped: return True
        stack = []
        i, j = 0, 0
        while i < len(pushed):
            stack.append(pushed[i])
            while stack and stack[-1] == popped[j]:
                stack.pop()
                j += 1
            i += 1
        
        return True if len(stack) == 0 else False
```
