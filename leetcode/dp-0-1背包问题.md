# 0-1背包问题
背包问题：**容量为W的背包和N个物品，每个物品有重量和价值两个属性。其中第i个物品的重量为wt[i]，价值为val[i]，现在让你用这个背包装物品，最多能装的价值为多少**  
0-1背包问题是：**题目中的物品不可以分割，要么装进背包要么不装**。  
对0-1背包问题的动态规划解法也是按照标准套路。
1. 先明确**状态**和**选择**    
状态：**背包的容量**和**可选择的物品**。  
选择：**装进背包**和**不装进背包**。  
由此套用dp的框架：
```python
for 状态1 in 状态1的所有取值：
  for 状态2 in 状态2的所有取值：
    for ...
      dp[状态1][状态2][...] = 择优(选择1，选择2，...)
```
2. 然后明确dp数组的定义  
0-1背包问题的状态有两个，所以需要一个二维dp数组，一维表示可选择的物品，一维表示背包容量。  
所以dp[i][w]定义为对于前i个物品，当前背包的容量为w，这种情况下可以装的最大价值是dp[i][w]。而最终的答案是dp[N][W], base case是dp[0][..] = dp[..][0]，因为没有物品或者背包没有空间的时候，能装的最大价值就是0。  
由此框架变为：
```python
dp[N+1][W+1]
dp[0][..] = 0
dp[..][0] = 0
for i in range(1, N):
  for w in range(1, W):
    dp[i][w] = max(把物品i装进背包， 不把物品i装进背包)
return dp[N][W]
```
3. 根据**选择**思考状态转移的逻辑  
这一步就要写出dp的状态转移方程，把物品i装进背包，则这个状态应该是dp[i-1][w-wt[i-1]] + val[i-1]，而没有把物品i装进背包的状态是dp[i-1][w]。则dp方程就是：
```python
dp[i][w] = max(dp[i-1][w], dp[i-1][w-wt[i-1]] + val[i-1])
```
则最后的0-1背包问题的框架就是：
```python
dp[N+1][W+1]
dp[0][..] = 0
dp[..][0] = 0
for i in range(1, N):
  for w in range(1, W):
  if w - wt[i-1] < 0:
    dp[i][w] = dp[i-1][w]
  else:
    dp[i][w] = max(dp[i-1][w], dp[i-1][w-wt[i-1]] + val[i-1])

return dp[N][W]
```
