# 股票买卖题目框架
股票买卖的框架其实非常清晰，从目前的题目看都可以用动态规划表来做。  

根据labuladong的总股票框架来说：如下三维数组框架适用所有的股票问题：
```python
dp[i][j][0 or 1]
# 0 <= i <= n - 1, 1<=k<=K, n为天数，K为最多交易次数

for i in range(n):
    for k in range(1, K):
        for s in {0, 1}:
            # dp[i][k][s] = max(buy, sell, rest)
            dp[i][k][s] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) # (rest或者sell)
            dp[i][k][s] = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i]) # (rest或者buy)

# base case：
dp[-1][k][0] = dp[i][0][0] = 0
dp[-1][k][1] = dp[i][0][1] = -infinity
```

#### LC121.单次交易的买卖股票最佳时机
这道easy级别的题目，入手点就是dp，则首先要考虑的就是dp方程要如何写。  
dp方程是在每一天对比今天卖出的利益和昨天的最大利益作比较，取较大值作为新的最大收益。并且在遍历每天的时候要及时更新最低价格作为买入价。
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if not prices: return 0
        max_profit = 0
        min_price = prices[0]
        for i in range(len(prices)):
            if min_price > prices[i]:
                min_price = prices[i]
            max_profit = max(max_profit, prices[i] - min_price)
        return max_profit
```
#### LC122.多次交易的买卖股票最佳时机
非框架型写法。多次交易的话，策略为每日交易，上涨交易日进行买卖，而下跌交易日不买买。
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        profit = 0
        for i in range(1, len(prices)):
            tmp = prices[i] - prices[i - 1]
            if tmp > 0: profit += tmp
        return profit
```
