# 滑动窗口框架
滑动窗口属于一种高级的双指针解题技巧，通常用来解决连续问题。其解题框架也十分简单，维护一个窗口，不断滑动，然后更新答案。
```python
left, right = 0, 0
while right <len(s):
    # 增大窗口
    window.add(s[right])
    right += 1
    
    # 缩小窗口
    while window needs shrink:
        window.remove(s[left])
        left += 1
```
整体代码框架是：
```python
def slideWindow(s, t):
    import sys
    need = collections.defaultdict(int)
    window = collections.defaultdict(int)
    for c in t:
        need[c] += 1
    left, right, valid = 0, 0, 0
    while right < len(s):
        # c是将移入窗口的字符
        c = s[right]
        # 右移窗口
        right += 1
        # 进行窗口数据的一系列更新
        ...
        ### debug输出的位置 ###
        print（'window:%s:%s' % (left, right))
        ######################
        
        # 判断左侧窗口是否要收缩
        while window needs shrik:
            # d是将移出窗口的字符
            d = s[left]
            # 左移窗口
            left += 1
            # 进行窗口内数据的一系列更新
            ...
```
#### LC76.最小覆盖子串（hard）
这道题整体的思路是这样的：  
1. 我们在字符串S中使用双指针中的左右指针技巧，初始化left = right = 0，把索引左闭右开区间[left, right)称为一个「窗口」。  
2. 我们先不断地增加right指针扩大窗口[left, right)，直到窗口中的字符串符合要求（包含了T中的所有字符）。  
3. 此时，我们停止增加right，转而不断增加left指针缩小窗口[left, right)，直到窗口中的字符串不再符合要求（不包含T中的所有字符了）。同时，每次增加left，我们都要更新一轮结果。  
4. 重复第 2 和第 3 步，直到right到达字符串S的尽头。

**时间复杂度: O($N^2$)**

根据上述思路写成的代码如下：
```python
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        need = collections.defaultdict(int)
        window = collections.defaultdict(int)
        import sys
        for c in t:
            need[c] += 1    
        left, right, valid = 0, 0, 0
        start, length = 0, sys.maxsize
        while right < len(s):
            c = s[right]
            right += 1
            if c in need.keys():
                window[c] += 1
                if window[c] == need[c]:
                    valid += 1
        
            while valid == len(need):
                if right - left <length:
                    start = left
                    length = right - left
                
                d = s[left]
                left += 1
                if d in need.keys():
                    if window[d] == need[d]:
                        valid -= 1
                    window[d] -= 1
        return s[start: start + length] if length != sys.maxsize else ''
```

#### LC567.字符串排列
这道题的解法跟76大同小异，只需要修改两个地方。
- left缩小窗口的时机是窗口大于len(s1)时。
- 当发现valid == len(need)时，就说明窗口中就是一个合法的排列，所以立即返回True。
在处理窗口扩大和缩小上和最小覆盖字串完全相同。  

**时间复杂度:O($N^2$)**
```python
class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        import sys
        need = collections.defaultdict(int)
        window = collections.defaultdict(int)
        for c in s1: need[c] += 1
        left, right, valid = 0, 0, 0
        while right < len(s2):
            c = s2[right]
            right += 1
            if c in need.keys():
                window[c] += 1
                if window[c] == need[c]:
                    valid += 1

            while right - left >= len(s1):
                if valid == len(need):
                    return True
                d = s2[left]
                left += 1
                if d in need.keys():
                    if window[d] == need[d]:
                        valid -= 1
                    window[d] -= 1
                
        return False
```
