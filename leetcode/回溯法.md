# 回溯法框架总结
回溯法主要解决的是决策树的遍历过程，只需要考虑三个问题：  
- 路径：已经做出的选择。
- 选择列表：当前可以做出的选择。
- 结束条件：到达决策树底层，无法在作出选择的条件。  

算法框架：
```python
result = []
def backtrack(路径, 选择列表):
    if 满⾜结束条件:
        result.add(路径)
        return
    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```
个人对于上述框架中回溯知乎撤销选择的理解为：为了选择另一条路径，则必须撤回已经迈向这条路径的一步，才能选择另一条路径。

#### LC17.电话号码组合
捋一下这道题，就能看到是要找所有组合，第一感觉就是回溯。电话号码对应字母很容易想到要建立字典来对应查询。回溯法的框架是一个递归函数，这里整理好递归的细节。  
只要next_digits长度不为0，那么就把next_digits的第0位拿出来，查出其在字典中对应的字母，并逐个进行回溯。当next_digits为0时，就把combination加入到result内部。
```python
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        phone = {'2': ['a', 'b', 'c'],
                 '3': ['d', 'e', 'f'],
                 '4': ['g', 'h', 'i'],
                 '5': ['j', 'k', 'l'],
                 '6': ['m', 'n', 'o'],
                 '7': ['p', 'q', 'r', 's'],
                 '8': ['t', 'u', 'v'],
                 '9': ['w', 'x', 'y', 'z']}
        def backtracking(combination, next_digits):
            if len(next_digits) == 0:
                result.append(combination)
            else:
                for letter in phone[next_digits[0]]:
                    backtracking(combination + letter, next_digits[1:])
        result = []
        if digits:
            backtracking('', digits)
        return result
```

#### LC79.单词搜索
明显的寻找路径问题，或者遍历过程，回溯法或者dfs可以解答这个问题。在这里我们需要在一个二维空间上去寻找路径，所以定义dfs在两层循环上去对每一个单元去做dfs。  
dfs函数设计（输入为：二维数组，行号，列号，单词）：
- 这里是一个递归的方程，则最终的停止条件为，单词为空；或者超出边界以及单词的下一个字母找不到路径。
- 在dfs之前建立一个防止走回路的机制，并在递归后释放。
- 在防止回路的中间开始回溯发散寻找。

```python
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        if not board: return False
        for i in range(len(board)):
            for j in range(len(board[0])):
                if self.dfs(board, i, j, word):
                    return True
        return False

    def dfs(self, board, i, j, word):
        if len(word) == 0: return True
        if i < 0 or i >= len(board) or j < 0 or j >=len(board[0]) or word[0] != board[i][j]:
            return False
        tmp = board[i][j]
        board[i][j] = '0'
        res = self.dfs(board, i+1, j, word[1:]) or self.dfs(board, i-1, j, word[1:]) or self.dfs(board, i, j+1, word[1:]) or self.dfs(board, i, j-1, word[1:])
        board[i][j] = tmp
        return res
```

#### LC46.全排列
按照[liweiwei](https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/)大神对这道题的细致讲解，给出来的这个版本的dfs或者说回溯是一个比较标准版的版本。
```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        def dfs(nums, size, depth, path, used, res):
            if depth == size:
                res.append(path[:])
                return
            
            for i in range(size):
                if not used[i]:
                    used[i] = True
                    path.append(nums[i])

                    dfs(nums, size, depth+1, path, used, res)

                    used[i] = False
                    path.pop()

        size = len(nums)
        if len(nums) == 0:
            return []
        
        used = [False for _ in range(size)]
        res = []
        dfs(nums, size, 0, [], used, res)
        return res
```
