# 总结二分查找框架和题目
### 关键词：有序数组，寻找一个数，寻找左边界，寻找右边界。  
二分法的时间复杂度都为O(logn)。  
例题：递增数列找数, 有数组和目标数，有则返回目标数下标，没有则返回-1。
```python
def binary_search(nums, target):
    left, right = 0, len(nums)-1
    while left <= right:
        mid = (left + right) // 2
        if target == nums[mid]: return mid
        elif nums[mid] > target:
            right = mid - 1
        else:
            left = mid + 1
    return -1
```
#### LC33.搜索旋转数组。  
升序数组某个点进行了旋转，搜索target的索引，找不到返回-1。  
思路：这里用二分法主要是为了满足题目要求的时间复杂度，同样点题是寻找有序数组中的某个值。这里对传统的二分法进行一点改进。多加一步对单边有序判断，如果mid比left大，则左边有序，否则右边有序。然后分别在两种情况下进行二分范围缩小。
```python
def search(nums, target):
    inf not nums: return -1
    left, right = 0, len(nums)-1
    while left <= right:
        mid = (left + right)//2
        if nums[mid] = target: return mid
        if nums[mid] >= nums[left]:
            if nums[left] <= target <= nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if nums[mid] <= target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    return -1
```
如果对例题稍作要求，则可以提出如下要求。  
#### 剑指53-1.排序数组中返回target出现的次数。  
这里可以用二分法做两次查找，分别查找target和target-1的下标，然后进行相减就可以求得出现的次数。需要注意的地方是，这里有出现目标数多次的情况，则将相等的情况合并到小于中，left得以找到右边界并返回。  
```python
def search(nums, target):
    def helper(tar):
        left, right = 0, len(nums)-1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] > tar:
                right = mid - 1
            elif nums[mid] <= tar:
                left = mid + 1
        return left
    return helper(target) - helper(target - 1)
```

#### LC34.排序数组中查找元素的第一个和最后一个位置。  
这里是对上面剑指的题目的改进，其实还是计算了一个排序数组中有重复数的长度，只是输出不同。上面的题目在于helper函数返回的是target最右端索引+1，并且排序数组中并不是递增。所以这里要用到二分查找的两个变形：左边界和右边界。  
左边界跟原查找的差别在于等于包到了target小于的情况，并且判断left是否有效。  
有边界跟左边界的差别在于等于包到target大于的情况下，并且判断right是否有效，返回right。  
```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        def tail_helper(tar):
            left, right = 0, len(nums) - 1
            while left <= right:
                mid = (right + left) // 2
                if tar <= nums[mid]:
                    right = mid - 1
                else:
                    left = mid + 1
            if left >= len(nums) or nums[left] != tar: return -1
            return left
        
        def head_helper(tar):
            left, right = 0, len(nums) - 1
            while left <= right:
                mid = (left + right) // 2
                if tar < nums[mid]:
                    right = mid - 1
                else:
                    left = mid + 1
            if right < 0 or nums[left - 1] != tar: return -1
            return right
        
        if not nums: return [-1,-1]
        tail = tail_helper(target)
        head = head_helper(target)
        return [tail, head]
```
