# 总结二分查找框架和题目
### 关键词：有序数组，寻找一个数，寻找左边界，寻找右边界。  
二分法的时间复杂度都为O(logn)。  
例题：递增数列找数, 有数组和目标数，有则返回目标数下标，没有则返回-1。
```python
def binary_search(nums, target):
    left, right = 0, len(nums)-1
    while left <= right:
        mid = (left + right) // 2
        if target == nums[mid]: return mid
        elif nums[mid] > target:
            right = mid - 1
        else:
            left = mid + 1
    return -1
```
LC33.搜索旋转数组。  
升序数组某个点进行了旋转，搜索target的索引，找不到返回-1。  
思路：这里用二分法主要是为了满足题目要求的时间复杂度，同样点题是寻找有序数组中的某个值。这里对传统的二分法进行一点改进。多加一步对单边有序判断，如果mid比left大，则左边有序，否则右边有序。然后分别在两种情况下进行二分范围缩小。
```python
def search(nums, target):
    inf not nums: return -1
    left, right = 0, len(nums)-1
    while left <= right:
        mid = (left + right)//2
        if nums[mid] = target: return mid
        if nums[mid] >= nums[left]:
            if nums[left] <= target <= nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if nums[mid] <= target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    return -1
```
如果对例题稍作要求，则可以提出如下要求。  
剑指53-1.排序数组中返回target出现的次数。  
这里可以用二分法做两次查找，分别查找target和target-1的下标，然后进行相减就可以求得出现的次数。需要注意的地方是，这里有出现目标数多次的情况，则将相等的情况合并到小于中，left得以找到右边界并返回。  
```python
def search(nums, target):
    def helper(tar):
        left, right = 0, len(nums)-1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] > tar:
                right = mid - 1
            elif nums[mid] <= tar:
                left = mid + 1
        return left
    return helper(target) - helper(target - 1)
```
